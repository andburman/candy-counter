{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///Users/burman/repos/candy-counter/candy-counter/lib/db.ts"],"sourcesContent":["import Database from \"better-sqlite3\";\nimport { join } from \"path\";\n\nlet db: Database.Database | null = null;\n\n/**\n * Get or create the database connection\n * Singleton pattern to ensure only one connection\n */\nexport function getDb(): Database.Database {\n  if (db) {\n    return db;\n  }\n\n  // Create database in the project root\n  const dbPath = join(process.cwd(), \"candy-counter.db\");\n  db = new Database(dbPath);\n  \n  // Enable foreign keys\n  db.pragma(\"foreign_keys = ON\");\n  \n  // Initialize schema\n  initializeSchema(db);\n  \n  return db;\n}\n\n/**\n * Initialize the database schema\n */\nfunction initializeSchema(database: Database.Database) {\n  const currentYear = new Date().getFullYear();\n\n  // Create candy counts table\n  database.exec(`\n    CREATE TABLE IF NOT EXISTS candy_counts (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      candy_name TEXT NOT NULL,\n      count INTEGER NOT NULL DEFAULT 0,\n      year INTEGER NOT NULL,\n      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(candy_name, year)\n    );\n  `);\n\n  // Migration: Add year column if it doesn't exist\n  try {\n    const tableInfo = database.prepare(\"PRAGMA table_info(candy_counts)\").all() as Array<{ name: string; type: string }>;\n    const hasYearColumn = tableInfo.some((col) => col.name === \"year\");\n\n    if (!hasYearColumn) {\n      // Add year column\n      database.exec(`\n        ALTER TABLE candy_counts ADD COLUMN year INTEGER;\n      `);\n\n      // Migrate existing records to current year\n      database.exec(`\n        UPDATE candy_counts SET year = ${currentYear} WHERE year IS NULL;\n      `);\n\n      // Make year NOT NULL after populating\n      database.exec(`\n        CREATE TABLE candy_counts_new (\n          id INTEGER PRIMARY KEY AUTOINCREMENT,\n          candy_name TEXT NOT NULL,\n          count INTEGER NOT NULL DEFAULT 0,\n          year INTEGER NOT NULL,\n          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n          updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n          UNIQUE(candy_name, year)\n        );\n      `);\n\n      database.exec(`\n        INSERT INTO candy_counts_new (id, candy_name, count, year, created_at, updated_at)\n        SELECT id, candy_name, count, year, created_at, updated_at FROM candy_counts;\n      `);\n\n      database.exec(`\n        DROP TABLE candy_counts;\n      `);\n\n      database.exec(`\n        ALTER TABLE candy_counts_new RENAME TO candy_counts;\n      `);\n\n      // Drop old index if it exists\n      try {\n        database.exec(`DROP INDEX IF EXISTS idx_candy_name;`);\n      } catch (e) {\n        // Index might not exist, ignore\n      }\n    }\n\n    // Drop old unique constraint on candy_name if it exists\n    // SQLite doesn't support dropping constraints directly, handled via table recreation above\n  } catch (e) {\n    // If migration fails, continue (might already be migrated)\n    console.error(\"Migration error (may be expected):\", e);\n  }\n\n  // Create index on candy_name and year for faster lookups\n  database.exec(`\n    CREATE INDEX IF NOT EXISTS idx_candy_name_year ON candy_counts(candy_name, year);\n  `);\n\n  // Create trigger to update updated_at timestamp\n  database.exec(`\n    CREATE TRIGGER IF NOT EXISTS update_candy_counts_timestamp \n    AFTER UPDATE ON candy_counts\n    BEGIN\n      UPDATE candy_counts \n      SET updated_at = CURRENT_TIMESTAMP \n      WHERE id = NEW.id;\n    END;\n  `);\n\n  // ===== CANDY CATALOG MIGRATION =====\n  \n  // Create candy_catalog table\n  database.exec(`\n    CREATE TABLE IF NOT EXISTS candy_catalog (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      name TEXT NOT NULL UNIQUE,\n      description TEXT,\n      is_active INTEGER NOT NULL DEFAULT 1,\n      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n    );\n  `);\n\n  // Create trigger to update updated_at timestamp for catalog\n  database.exec(`\n    CREATE TRIGGER IF NOT EXISTS update_candy_catalog_timestamp \n    AFTER UPDATE ON candy_catalog\n    BEGIN\n      UPDATE candy_catalog \n      SET updated_at = CURRENT_TIMESTAMP \n      WHERE id = NEW.id;\n    END;\n  `);\n\n  // Migration: Add catalog_id column if it doesn't exist\n  try {\n    const candyTableInfo = database.prepare(\"PRAGMA table_info(candy_counts)\").all() as Array<{ name: string; type: string }>;\n    const hasCatalogIdColumn = candyTableInfo.some((col) => col.name === \"catalog_id\");\n\n    if (!hasCatalogIdColumn) {\n      // Add catalog_id column (nullable initially)\n      database.exec(`\n        ALTER TABLE candy_counts ADD COLUMN catalog_id INTEGER;\n      `);\n\n      // Create index on catalog_id for performance\n      database.exec(`\n        CREATE INDEX IF NOT EXISTS idx_candy_catalog_id ON candy_counts(catalog_id);\n      `);\n    }\n  } catch (e) {\n    console.error(\"Catalog migration error (may be expected):\", e);\n  }\n\n  // Run migration to populate catalog and link existing records\n  migrateCatalogData(database);\n}\n\n/**\n * Migrate existing candy_name data to catalog system\n */\nfunction migrateCatalogData(database: Database.Database) {\n  try {\n    // Check if catalog is already populated by checking if any candy_counts have catalog_id set\n    const checkStmt = database.prepare(`\n      SELECT COUNT(*) as count \n      FROM candy_counts \n      WHERE catalog_id IS NOT NULL\n    `);\n    const result = checkStmt.get() as { count: number };\n    \n    // If catalog_id is already set, migration has been run\n    if (result.count > 0) {\n      return;\n    }\n\n    // Get all distinct candy names from candy_counts\n    const distinctNames = database.prepare(`\n      SELECT DISTINCT candy_name \n      FROM candy_counts \n      WHERE candy_name IS NOT NULL AND candy_name != ''\n    `).all() as Array<{ candy_name: string }>;\n\n    if (distinctNames.length === 0) {\n      return; // No data to migrate\n    }\n\n    // Populate catalog from existing candy names\n    const insertStmt = database.prepare(`\n      INSERT OR IGNORE INTO candy_catalog (name) \n      VALUES (?)\n    `);\n\n    for (const row of distinctNames) {\n      insertStmt.run(row.candy_name);\n    }\n\n    // Link existing candy_counts records to catalog\n    const linkStmt = database.prepare(`\n      UPDATE candy_counts \n      SET catalog_id = (\n        SELECT id \n        FROM candy_catalog \n        WHERE name = candy_counts.candy_name \n        LIMIT 1\n      )\n      WHERE catalog_id IS NULL\n    `);\n    linkStmt.run();\n\n  } catch (e) {\n    console.error(\"Catalog data migration error:\", e);\n  }\n}\n\n/**\n * Close the database connection (useful for cleanup)\n */\nexport function closeDb() {\n  if (db) {\n    db.close();\n    db = null;\n  }\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 212, "column": 0}, "map": {"version":3,"sources":["file:///Users/burman/repos/candy-counter/candy-counter/lib/candy.ts"],"sourcesContent":["import { getDb } from \"./db\";\n\nexport interface Candy {\n  id: number;\n  catalog_id: number;\n  candy_name: string; // Denormalized or from JOIN for display\n  count: number;\n  year: number;\n  created_at: string;\n  updated_at: string;\n}\n\n/**\n * Get the current year\n */\nexport function getCurrentYear(): number {\n  return new Date().getFullYear();\n}\n\n/**\n * Get all candy counts, optionally filtered by year\n */\nexport function getAllCandies(year?: number): Candy[] {\n  const db = getDb();\n  if (year !== undefined) {\n    const stmt = db.prepare(`\n      SELECT \n        cc.id,\n        cc.catalog_id,\n        COALESCE(cat.name, cc.candy_name) as candy_name,\n        cc.count,\n        cc.year,\n        cc.created_at,\n        cc.updated_at\n      FROM candy_counts cc\n      LEFT JOIN candy_catalog cat ON cc.catalog_id = cat.id\n      WHERE cc.year = ?\n      ORDER BY candy_name\n    `);\n    return stmt.all(year) as Candy[];\n  }\n  const stmt = db.prepare(`\n    SELECT \n      cc.id,\n      cc.catalog_id,\n      COALESCE(cat.name, cc.candy_name) as candy_name,\n      cc.count,\n      cc.year,\n      cc.created_at,\n      cc.updated_at\n    FROM candy_counts cc\n    LEFT JOIN candy_catalog cat ON cc.catalog_id = cat.id\n    ORDER BY cc.year DESC, candy_name\n  `);\n  return stmt.all() as Candy[];\n}\n\n/**\n * Get all candies for a specific year\n */\nexport function getCandiesByYear(year: number): Candy[] {\n  const db = getDb();\n  const stmt = db.prepare(`\n    SELECT \n      cc.id,\n      cc.catalog_id,\n      COALESCE(cat.name, cc.candy_name) as candy_name,\n      cc.count,\n      cc.year,\n      cc.created_at,\n      cc.updated_at\n    FROM candy_counts cc\n    LEFT JOIN candy_catalog cat ON cc.catalog_id = cat.id\n    WHERE cc.year = ?\n    ORDER BY candy_name\n  `);\n  return stmt.all(year) as Candy[];\n}\n\n/**\n * Get all available years that have candy data\n */\nexport function getAvailableYears(): number[] {\n  const db = getDb();\n  const stmt = db.prepare(\"SELECT DISTINCT year FROM candy_counts ORDER BY year DESC\");\n  const results = stmt.all() as Array<{ year: number }>;\n  return results.map((r) => r.year);\n}\n\n/**\n * Get a specific candy by name and year (deprecated - kept for backwards compatibility)\n * @deprecated Use getCandyByCatalogId or getCandyById instead\n */\nexport function getCandyByName(candyName: string, year?: number): Candy | null {\n  const db = getDb();\n  const targetYear = year ?? getCurrentYear();\n  const stmt = db.prepare(`\n    SELECT \n      cc.id,\n      cc.catalog_id,\n      COALESCE(cat.name, cc.candy_name) as candy_name,\n      cc.count,\n      cc.year,\n      cc.created_at,\n      cc.updated_at\n    FROM candy_counts cc\n    LEFT JOIN candy_catalog cat ON cc.catalog_id = cat.id\n    WHERE (cat.name = ? OR cc.candy_name = ?) AND cc.year = ?\n  `);\n  const candy = stmt.get(candyName, candyName, targetYear) as Candy | undefined;\n  return candy || null;\n}\n\n/**\n * Get a specific candy by catalog_id and year\n */\nexport function getCandyByCatalogId(catalogId: number, year?: number): Candy | null {\n  const db = getDb();\n  const targetYear = year ?? getCurrentYear();\n  const stmt = db.prepare(`\n    SELECT \n      cc.id,\n      cc.catalog_id,\n      COALESCE(cat.name, cc.candy_name) as candy_name,\n      cc.count,\n      cc.year,\n      cc.created_at,\n      cc.updated_at\n    FROM candy_counts cc\n    LEFT JOIN candy_catalog cat ON cc.catalog_id = cat.id\n    WHERE cc.catalog_id = ? AND cc.year = ?\n  `);\n  const candy = stmt.get(catalogId, targetYear) as Candy | undefined;\n  return candy || null;\n}\n\n/**\n * Get a specific candy by ID\n */\nexport function getCandyById(id: number): Candy | null {\n  const db = getDb();\n  const stmt = db.prepare(`\n    SELECT \n      cc.id,\n      cc.catalog_id,\n      COALESCE(cat.name, cc.candy_name) as candy_name,\n      cc.count,\n      cc.year,\n      cc.created_at,\n      cc.updated_at\n    FROM candy_counts cc\n    LEFT JOIN candy_catalog cat ON cc.catalog_id = cat.id\n    WHERE cc.id = ?\n  `);\n  const candy = stmt.get(id) as Candy | undefined;\n  return candy || null;\n}\n\n/**\n * Increment candy count (creates if doesn't exist) - uses catalog_id\n */\nexport function incrementCandy(catalogId: number, amount: number = 1, year?: number): Candy {\n  const db = getDb();\n  const targetYear = year ?? getCurrentYear();\n  \n  // Try to get existing candy\n  const existing = db.prepare(`\n    SELECT * FROM candy_counts \n    WHERE catalog_id = ? AND year = ?\n  `).get(catalogId, targetYear) as Candy | undefined;\n  \n  if (existing) {\n    // Update existing\n    const stmt = db.prepare(\n      \"UPDATE candy_counts SET count = count + ? WHERE catalog_id = ? AND year = ?\"\n    );\n    stmt.run(amount, catalogId, targetYear);\n    // Fetch the updated record\n    return getCandyById(existing.id)!;\n  } else {\n    // Get catalog name for denormalization\n    const catalogItem = db.prepare(\"SELECT name FROM candy_catalog WHERE id = ?\").get(catalogId) as { name: string } | undefined;\n    const candyName = catalogItem?.name || \"\";\n    \n    // Create new\n    const stmt = db.prepare(\n      \"INSERT INTO candy_counts (catalog_id, candy_name, count, year) VALUES (?, ?, ?, ?)\"\n    );\n    stmt.run(catalogId, candyName, amount, targetYear);\n    // Fetch the newly created record\n    const newId = db.prepare(\"SELECT last_insert_rowid()\").get() as { \"last_insert_rowid()\": number };\n    return getCandyById(newId[\"last_insert_rowid()\"])!;\n  }\n}\n\n/**\n * Decrement candy count (uses catalog_id)\n */\nexport function decrementCandy(catalogId: number, amount: number = 1, year?: number): Candy | null {\n  const db = getDb();\n  const targetYear = year ?? getCurrentYear();\n  const existing = getCandyByCatalogId(catalogId, targetYear);\n  \n  if (!existing) {\n    return null;\n  }\n  \n  const newCount = Math.max(0, existing.count - amount);\n  const stmt = db.prepare(\n    \"UPDATE candy_counts SET count = ? WHERE catalog_id = ? AND year = ?\"\n  );\n  stmt.run(newCount, catalogId, targetYear);\n  // Fetch the updated record\n  return getCandyByCatalogId(catalogId, targetYear)!;\n}\n\n/**\n * Set candy count to a specific value (uses catalog_id)\n */\nexport function setCandyCount(catalogId: number, count: number, year?: number): Candy {\n  const db = getDb();\n  const targetYear = year ?? getCurrentYear();\n  const existing = getCandyByCatalogId(catalogId, targetYear);\n  \n  if (existing) {\n    const stmt = db.prepare(\n      \"UPDATE candy_counts SET count = ? WHERE catalog_id = ? AND year = ?\"\n    );\n    stmt.run(count, catalogId, targetYear);\n    // Fetch the updated record\n    return getCandyByCatalogId(catalogId, targetYear)!;\n  } else {\n    // Get catalog name for denormalization\n    const catalogItem = db.prepare(\"SELECT name FROM candy_catalog WHERE id = ?\").get(catalogId) as { name: string } | undefined;\n    const candyName = catalogItem?.name || \"\";\n    \n    const stmt = db.prepare(\n      \"INSERT INTO candy_counts (catalog_id, candy_name, count, year) VALUES (?, ?, ?, ?)\"\n    );\n    stmt.run(catalogId, candyName, count, targetYear);\n    // Fetch the newly created record\n    const newId = db.prepare(\"SELECT last_insert_rowid()\").get() as { \"last_insert_rowid()\": number };\n    return getCandyById(newId[\"last_insert_rowid()\"])!;\n  }\n}\n\n/**\n * Delete a candy by ID\n */\nexport function deleteCandyById(id: number): boolean {\n  const db = getDb();\n  const stmt = db.prepare(\"DELETE FROM candy_counts WHERE id = ?\");\n  const result = stmt.run(id);\n  return result.changes > 0;\n}\n\n/**\n * Delete a candy by name and year (deprecated - kept for backwards compatibility)\n * @deprecated Use deleteCandyById instead\n */\nexport function deleteCandy(candyName: string, year?: number): boolean {\n  const db = getDb();\n  const targetYear = year ?? getCurrentYear();\n  const stmt = db.prepare(`\n    DELETE FROM candy_counts \n    WHERE id IN (\n      SELECT cc.id FROM candy_counts cc\n      LEFT JOIN candy_catalog cat ON cc.catalog_id = cat.id\n      WHERE (cat.name = ? OR cc.candy_name = ?) AND cc.year = ?\n    )\n  `);\n  const result = stmt.run(candyName, candyName, targetYear);\n  return result.changes > 0;\n}\n\n/**\n * Reset all candy counts to zero for a specific year\n */\nexport function resetAllCandies(year?: number): void {\n  const db = getDb();\n  if (year !== undefined) {\n    db.prepare(\"UPDATE candy_counts SET count = 0 WHERE year = ?\").run(year);\n  } else {\n    db.prepare(\"UPDATE candy_counts SET count = 0\").run();\n  }\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAeO,SAAS;IACd,OAAO,IAAI,OAAO,WAAW;AAC/B;AAKO,SAAS,cAAc,IAAa;IACzC,MAAM,KAAK,IAAA,mKAAK;IAChB,IAAI,SAAS,WAAW;QACtB,MAAM,OAAO,GAAG,OAAO,CAAC,CAAC;;;;;;;;;;;;;IAazB,CAAC;QACD,OAAO,KAAK,GAAG,CAAC;IAClB;IACA,MAAM,OAAO,GAAG,OAAO,CAAC,CAAC;;;;;;;;;;;;EAYzB,CAAC;IACD,OAAO,KAAK,GAAG;AACjB;AAKO,SAAS,iBAAiB,IAAY;IAC3C,MAAM,KAAK,IAAA,mKAAK;IAChB,MAAM,OAAO,GAAG,OAAO,CAAC,CAAC;;;;;;;;;;;;;EAazB,CAAC;IACD,OAAO,KAAK,GAAG,CAAC;AAClB;AAKO,SAAS;IACd,MAAM,KAAK,IAAA,mKAAK;IAChB,MAAM,OAAO,GAAG,OAAO,CAAC;IACxB,MAAM,UAAU,KAAK,GAAG;IACxB,OAAO,QAAQ,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI;AAClC;AAMO,SAAS,eAAe,SAAiB,EAAE,IAAa;IAC7D,MAAM,KAAK,IAAA,mKAAK;IAChB,MAAM,aAAa,QAAQ;IAC3B,MAAM,OAAO,GAAG,OAAO,CAAC,CAAC;;;;;;;;;;;;EAYzB,CAAC;IACD,MAAM,QAAQ,KAAK,GAAG,CAAC,WAAW,WAAW;IAC7C,OAAO,SAAS;AAClB;AAKO,SAAS,oBAAoB,SAAiB,EAAE,IAAa;IAClE,MAAM,KAAK,IAAA,mKAAK;IAChB,MAAM,aAAa,QAAQ;IAC3B,MAAM,OAAO,GAAG,OAAO,CAAC,CAAC;;;;;;;;;;;;EAYzB,CAAC;IACD,MAAM,QAAQ,KAAK,GAAG,CAAC,WAAW;IAClC,OAAO,SAAS;AAClB;AAKO,SAAS,aAAa,EAAU;IACrC,MAAM,KAAK,IAAA,mKAAK;IAChB,MAAM,OAAO,GAAG,OAAO,CAAC,CAAC;;;;;;;;;;;;EAYzB,CAAC;IACD,MAAM,QAAQ,KAAK,GAAG,CAAC;IACvB,OAAO,SAAS;AAClB;AAKO,SAAS,eAAe,SAAiB,EAAE,SAAiB,CAAC,EAAE,IAAa;IACjF,MAAM,KAAK,IAAA,mKAAK;IAChB,MAAM,aAAa,QAAQ;IAE3B,4BAA4B;IAC5B,MAAM,WAAW,GAAG,OAAO,CAAC,CAAC;;;EAG7B,CAAC,EAAE,GAAG,CAAC,WAAW;IAElB,IAAI,UAAU;QACZ,kBAAkB;QAClB,MAAM,OAAO,GAAG,OAAO,CACrB;QAEF,KAAK,GAAG,CAAC,QAAQ,WAAW;QAC5B,2BAA2B;QAC3B,OAAO,aAAa,SAAS,EAAE;IACjC,OAAO;QACL,uCAAuC;QACvC,MAAM,cAAc,GAAG,OAAO,CAAC,+CAA+C,GAAG,CAAC;QAClF,MAAM,YAAY,aAAa,QAAQ;QAEvC,aAAa;QACb,MAAM,OAAO,GAAG,OAAO,CACrB;QAEF,KAAK,GAAG,CAAC,WAAW,WAAW,QAAQ;QACvC,iCAAiC;QACjC,MAAM,QAAQ,GAAG,OAAO,CAAC,8BAA8B,GAAG;QAC1D,OAAO,aAAa,KAAK,CAAC,sBAAsB;IAClD;AACF;AAKO,SAAS,eAAe,SAAiB,EAAE,SAAiB,CAAC,EAAE,IAAa;IACjF,MAAM,KAAK,IAAA,mKAAK;IAChB,MAAM,aAAa,QAAQ;IAC3B,MAAM,WAAW,oBAAoB,WAAW;IAEhD,IAAI,CAAC,UAAU;QACb,OAAO;IACT;IAEA,MAAM,WAAW,KAAK,GAAG,CAAC,GAAG,SAAS,KAAK,GAAG;IAC9C,MAAM,OAAO,GAAG,OAAO,CACrB;IAEF,KAAK,GAAG,CAAC,UAAU,WAAW;IAC9B,2BAA2B;IAC3B,OAAO,oBAAoB,WAAW;AACxC;AAKO,SAAS,cAAc,SAAiB,EAAE,KAAa,EAAE,IAAa;IAC3E,MAAM,KAAK,IAAA,mKAAK;IAChB,MAAM,aAAa,QAAQ;IAC3B,MAAM,WAAW,oBAAoB,WAAW;IAEhD,IAAI,UAAU;QACZ,MAAM,OAAO,GAAG,OAAO,CACrB;QAEF,KAAK,GAAG,CAAC,OAAO,WAAW;QAC3B,2BAA2B;QAC3B,OAAO,oBAAoB,WAAW;IACxC,OAAO;QACL,uCAAuC;QACvC,MAAM,cAAc,GAAG,OAAO,CAAC,+CAA+C,GAAG,CAAC;QAClF,MAAM,YAAY,aAAa,QAAQ;QAEvC,MAAM,OAAO,GAAG,OAAO,CACrB;QAEF,KAAK,GAAG,CAAC,WAAW,WAAW,OAAO;QACtC,iCAAiC;QACjC,MAAM,QAAQ,GAAG,OAAO,CAAC,8BAA8B,GAAG;QAC1D,OAAO,aAAa,KAAK,CAAC,sBAAsB;IAClD;AACF;AAKO,SAAS,gBAAgB,EAAU;IACxC,MAAM,KAAK,IAAA,mKAAK;IAChB,MAAM,OAAO,GAAG,OAAO,CAAC;IACxB,MAAM,SAAS,KAAK,GAAG,CAAC;IACxB,OAAO,OAAO,OAAO,GAAG;AAC1B;AAMO,SAAS,YAAY,SAAiB,EAAE,IAAa;IAC1D,MAAM,KAAK,IAAA,mKAAK;IAChB,MAAM,aAAa,QAAQ;IAC3B,MAAM,OAAO,GAAG,OAAO,CAAC,CAAC;;;;;;;EAOzB,CAAC;IACD,MAAM,SAAS,KAAK,GAAG,CAAC,WAAW,WAAW;IAC9C,OAAO,OAAO,OAAO,GAAG;AAC1B;AAKO,SAAS,gBAAgB,IAAa;IAC3C,MAAM,KAAK,IAAA,mKAAK;IAChB,IAAI,SAAS,WAAW;QACtB,GAAG,OAAO,CAAC,oDAAoD,GAAG,CAAC;IACrE,OAAO;QACL,GAAG,OAAO,CAAC,qCAAqC,GAAG;IACrD;AACF","debugId":null}},
    {"offset": {"line": 450, "column": 0}, "map": {"version":3,"sources":["file:///Users/burman/repos/candy-counter/candy-counter/lib/catalog.ts"],"sourcesContent":["import { getDb } from \"./db\";\n\nexport interface CandyCatalogItem {\n  id: number;\n  name: string;\n  description?: string;\n  is_active: boolean;\n  created_at: string;\n  updated_at: string;\n}\n\n/**\n * Get all catalog items, optionally filtering by active status\n */\nexport function getAllCatalogItems(includeInactive: boolean = false): CandyCatalogItem[] {\n  const db = getDb();\n  \n  if (includeInactive) {\n    const stmt = db.prepare(\"SELECT * FROM candy_catalog ORDER BY name\");\n    return stmt.all() as CandyCatalogItem[];\n  } else {\n    const stmt = db.prepare(\"SELECT * FROM candy_catalog WHERE is_active = 1 ORDER BY name\");\n    return stmt.all() as CandyCatalogItem[];\n  }\n}\n\n/**\n * Get a specific catalog item by ID\n */\nexport function getCatalogItemById(id: number): CandyCatalogItem | null {\n  const db = getDb();\n  const stmt = db.prepare(\"SELECT * FROM candy_catalog WHERE id = ?\");\n  const item = stmt.get(id) as CandyCatalogItem | undefined;\n  return item || null;\n}\n\n/**\n * Get a specific catalog item by name\n */\nexport function getCatalogItemByName(name: string): CandyCatalogItem | null {\n  const db = getDb();\n  const stmt = db.prepare(\"SELECT * FROM candy_catalog WHERE name = ?\");\n  const item = stmt.get(name) as CandyCatalogItem | undefined;\n  return item || null;\n}\n\n/**\n * Create a new catalog item\n */\nexport function createCatalogItem(name: string, description?: string): CandyCatalogItem {\n  const db = getDb();\n  \n  // Check if item with this name already exists\n  const existing = getCatalogItemByName(name);\n  if (existing) {\n    throw new Error(`Candy catalog item with name \"${name}\" already exists`);\n  }\n  \n  const stmt = db.prepare(`\n    INSERT INTO candy_catalog (name, description, is_active) \n    VALUES (?, ?, 1)\n  `);\n  stmt.run(name.trim(), description?.trim() || null);\n  \n  const created = getCatalogItemByName(name);\n  if (!created) {\n    throw new Error(\"Failed to create catalog item\");\n  }\n  \n  return created;\n}\n\n/**\n * Update an existing catalog item\n */\nexport function updateCatalogItem(\n  id: number,\n  name: string,\n  description?: string\n): CandyCatalogItem {\n  const db = getDb();\n  \n  const existing = getCatalogItemById(id);\n  if (!existing) {\n    throw new Error(\"Catalog item not found\");\n  }\n  \n  // If name changed, check if new name already exists\n  if (name.trim() !== existing.name) {\n    const nameExists = getCatalogItemByName(name.trim());\n    if (nameExists && nameExists.id !== id) {\n      throw new Error(`Candy catalog item with name \"${name}\" already exists`);\n    }\n  }\n  \n  const stmt = db.prepare(`\n    UPDATE candy_catalog \n    SET name = ?, description = ? \n    WHERE id = ?\n  `);\n  stmt.run(name.trim(), description?.trim() || null, id);\n  \n  const updated = getCatalogItemById(id);\n  if (!updated) {\n    throw new Error(\"Failed to update catalog item\");\n  }\n  \n  return updated;\n}\n\n/**\n * Deactivate a catalog item (soft delete)\n */\nexport function deactivateCatalogItem(id: number): boolean {\n  const db = getDb();\n  \n  const existing = getCatalogItemById(id);\n  if (!existing) {\n    return false;\n  }\n  \n  const stmt = db.prepare(\"UPDATE candy_catalog SET is_active = 0 WHERE id = ?\");\n  const result = stmt.run(id);\n  \n  return result.changes > 0;\n}\n\n/**\n * Reactivate a catalog item\n */\nexport function activateCatalogItem(id: number): boolean {\n  const db = getDb();\n  \n  const existing = getCatalogItemById(id);\n  if (!existing) {\n    return false;\n  }\n  \n  const stmt = db.prepare(\"UPDATE candy_catalog SET is_active = 1 WHERE id = ?\");\n  const result = stmt.run(id);\n  \n  return result.changes > 0;\n}\n\n/**\n * Merge two catalog items - moves all candy_counts from source to target and deactivates source\n */\nexport function mergeCatalogItems(sourceId: number, targetId: number): boolean {\n  const db = getDb();\n  \n  const source = getCatalogItemById(sourceId);\n  const target = getCatalogItemById(targetId);\n  \n  if (!source || !target) {\n    throw new Error(\"Source or target catalog item not found\");\n  }\n  \n  if (sourceId === targetId) {\n    throw new Error(\"Cannot merge catalog item with itself\");\n  }\n  \n  // Use a transaction to ensure atomicity\n  const transaction = db.transaction(() => {\n    // First, get all records that need to be merged\n    const sourceRecords = db.prepare(`\n      SELECT * FROM candy_counts WHERE catalog_id = ?\n    `).all(sourceId) as Array<{ id: number; year: number; count: number }>;\n    \n    for (const record of sourceRecords) {\n      // Check if target already has a record for this year\n      const existingTarget = db.prepare(`\n        SELECT * FROM candy_counts \n        WHERE catalog_id = ? AND year = ?\n      `).get(targetId, record.year) as { id: number; count: number } | undefined;\n      \n      if (existingTarget) {\n        // Merge counts: add source count to target\n        const mergeStmt = db.prepare(`\n          UPDATE candy_counts \n          SET count = count + ? \n          WHERE id = ?\n        `);\n        mergeStmt.run(record.count, existingTarget.id);\n        \n        // Delete the source record since it's been merged\n        const deleteStmt = db.prepare(\"DELETE FROM candy_counts WHERE id = ?\");\n        deleteStmt.run(record.id);\n      } else {\n        // No conflict, just update the catalog_id\n        const updateStmt = db.prepare(`\n          UPDATE candy_counts \n          SET catalog_id = ? \n          WHERE id = ?\n        `);\n        updateStmt.run(targetId, record.id);\n      }\n    }\n    \n    // Deactivate source catalog item\n    db.prepare(\"UPDATE candy_catalog SET is_active = 0 WHERE id = ?\").run(sourceId);\n  });\n  \n  try {\n    transaction();\n    return true;\n  } catch (e) {\n    console.error(\"Error merging catalog items:\", e);\n    throw new Error(\"Failed to merge catalog items\");\n  }\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 613, "column": 0}, "map": {"version":3,"sources":["file:///Users/burman/repos/candy-counter/candy-counter/app/actions.ts"],"sourcesContent":["\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport {\n  getAllCandies,\n  getCandiesByYear,\n  getAvailableYears,\n  incrementCandy,\n  getCandyById,\n  deleteCandy as deleteCandyByName,\n  deleteCandyById,\n  setCandyCount,\n  getCandyByName,\n  getCurrentYear,\n  type Candy,\n} from \"@/lib/candy\";\nimport {\n  getAllCatalogItems,\n  getCatalogItemById,\n  createCatalogItem,\n  updateCatalogItem,\n  deactivateCatalogItem,\n  activateCatalogItem,\n  mergeCatalogItems,\n  type CandyCatalogItem,\n} from \"@/lib/catalog\";\nimport { getDb } from \"@/lib/db\";\n\n/**\n * Add candy (increments if exists, creates if new) - uses catalog_id\n */\nexport async function addCandy(catalogId: number, quantity: number): Promise<Candy> {\n  if (!catalogId || catalogId < 1) {\n    throw new Error(\"Valid catalog ID is required\");\n  }\n  if (quantity < 1) {\n    throw new Error(\"Quantity must be at least 1\");\n  }\n  \n  const candy = incrementCandy(catalogId, quantity);\n  revalidatePath(\"/\");\n  return candy;\n}\n\n/**\n * Get all candies, optionally filtered by year\n */\nexport async function getAllCandiesAction(year?: number): Promise<Candy[]> {\n  return getAllCandies(year);\n}\n\n/**\n * Get all candies for a specific year\n */\nexport async function getCandiesByYearAction(year: number): Promise<Candy[]> {\n  return getCandiesByYear(year);\n}\n\n/**\n * Get all available years that have candy data\n */\nexport async function getAvailableYearsAction(): Promise<number[]> {\n  const years = getAvailableYears();\n  const currentYear = getCurrentYear();\n  // Ensure current year is always included even if no data exists yet\n  if (!years.includes(currentYear)) {\n    return [currentYear, ...years];\n  }\n  return years;\n}\n\n/**\n * Update candy by ID (updates catalog_id and/or count)\n */\nexport async function updateCandy(\n  id: number,\n  catalogId: number,\n  count: number\n): Promise<Candy> {\n  if (!catalogId || catalogId < 1) {\n    throw new Error(\"Valid catalog ID is required\");\n  }\n  if (count < 0) {\n    throw new Error(\"Count cannot be negative\");\n  }\n\n  const existing = getCandyById(id);\n  if (!existing) {\n    throw new Error(\"Candy not found\");\n  }\n\n  const db = getDb();\n\n  // Check if catalog_id changed\n  if (catalogId !== existing.catalog_id) {\n    // Check if this catalog_id already exists for this year\n    const existingForYear = db.prepare(`\n      SELECT * FROM candy_counts \n      WHERE catalog_id = ? AND year = ? AND id != ?\n    `).get(catalogId, existing.year, id);\n    \n    if (existingForYear) {\n      throw new Error(\"This candy type already exists for this year\");\n    }\n  }\n\n  // Get catalog name for denormalization\n  const catalogItem = db.prepare(\"SELECT name FROM candy_catalog WHERE id = ?\").get(catalogId) as { name: string } | undefined;\n  const candyName = catalogItem?.name || \"\";\n\n  // Update both catalog_id and count\n  const stmt = db.prepare(\n    \"UPDATE candy_counts SET catalog_id = ?, candy_name = ?, count = ? WHERE id = ?\"\n  );\n  stmt.run(catalogId, candyName, count, id);\n\n  const updated = getCandyById(id);\n  if (!updated) {\n    throw new Error(\"Failed to update candy\");\n  }\n\n  revalidatePath(\"/\");\n  return updated;\n}\n\n/**\n * Delete candy by ID\n */\nexport async function deleteCandy(id: number): Promise<boolean> {\n  const existing = getCandyById(id);\n  if (!existing) {\n    return false;\n  }\n\n  const result = deleteCandyById(id);\n  revalidatePath(\"/\");\n  return result;\n}\n\n// ===== CATALOG MANAGEMENT ACTIONS =====\n\n/**\n * Get all catalog items\n */\nexport async function getAllCatalogItemsAction(includeInactive: boolean = false): Promise<CandyCatalogItem[]> {\n  return getAllCatalogItems(includeInactive);\n}\n\n/**\n * Create a new catalog item\n */\nexport async function createCatalogItemAction(name: string, description?: string): Promise<CandyCatalogItem> {\n  if (!name || name.trim() === \"\") {\n    throw new Error(\"Candy name is required\");\n  }\n  \n  const item = createCatalogItem(name.trim(), description?.trim());\n  revalidatePath(\"/\");\n  return item;\n}\n\n/**\n * Update an existing catalog item\n */\nexport async function updateCatalogItemAction(\n  id: number,\n  name: string,\n  description?: string\n): Promise<CandyCatalogItem> {\n  if (!name || name.trim() === \"\") {\n    throw new Error(\"Candy name is required\");\n  }\n  \n  const item = updateCatalogItem(id, name.trim(), description?.trim());\n  revalidatePath(\"/\");\n  return item;\n}\n\n/**\n * Deactivate a catalog item\n */\nexport async function deactivateCatalogItemAction(id: number): Promise<boolean> {\n  const result = deactivateCatalogItem(id);\n  revalidatePath(\"/\");\n  return result;\n}\n\n/**\n * Activate a catalog item\n */\nexport async function activateCatalogItemAction(id: number): Promise<boolean> {\n  const result = activateCatalogItem(id);\n  revalidatePath(\"/\");\n  return result;\n}\n\n/**\n * Merge two catalog items (source into target)\n */\nexport async function mergeCatalogItemsAction(sourceId: number, targetId: number): Promise<boolean> {\n  const result = mergeCatalogItems(sourceId, targetId);\n  revalidatePath(\"/\");\n  return result;\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AAaA;AAUA;;;;;;;AAKO,eAAe,SAAS,SAAiB,EAAE,QAAgB;IAChE,IAAI,CAAC,aAAa,YAAY,GAAG;QAC/B,MAAM,IAAI,MAAM;IAClB;IACA,IAAI,WAAW,GAAG;QAChB,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,QAAQ,IAAA,+KAAc,EAAC,WAAW;IACxC,IAAA,gMAAc,EAAC;IACf,OAAO;AACT;AAKO,eAAe,oBAAoB,IAAa;IACrD,OAAO,IAAA,8KAAa,EAAC;AACvB;AAKO,eAAe,uBAAuB,IAAY;IACvD,OAAO,IAAA,iLAAgB,EAAC;AAC1B;AAKO,eAAe;IACpB,MAAM,QAAQ,IAAA,kLAAiB;IAC/B,MAAM,cAAc,IAAA,+KAAc;IAClC,oEAAoE;IACpE,IAAI,CAAC,MAAM,QAAQ,CAAC,cAAc;QAChC,OAAO;YAAC;eAAgB;SAAM;IAChC;IACA,OAAO;AACT;AAKO,eAAe,YACpB,EAAU,EACV,SAAiB,EACjB,KAAa;IAEb,IAAI,CAAC,aAAa,YAAY,GAAG;QAC/B,MAAM,IAAI,MAAM;IAClB;IACA,IAAI,QAAQ,GAAG;QACb,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,WAAW,IAAA,6KAAY,EAAC;IAC9B,IAAI,CAAC,UAAU;QACb,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,KAAK,IAAA,mKAAK;IAEhB,8BAA8B;IAC9B,IAAI,cAAc,SAAS,UAAU,EAAE;QACrC,wDAAwD;QACxD,MAAM,kBAAkB,GAAG,OAAO,CAAC,CAAC;;;IAGpC,CAAC,EAAE,GAAG,CAAC,WAAW,SAAS,IAAI,EAAE;QAEjC,IAAI,iBAAiB;YACnB,MAAM,IAAI,MAAM;QAClB;IACF;IAEA,uCAAuC;IACvC,MAAM,cAAc,GAAG,OAAO,CAAC,+CAA+C,GAAG,CAAC;IAClF,MAAM,YAAY,aAAa,QAAQ;IAEvC,mCAAmC;IACnC,MAAM,OAAO,GAAG,OAAO,CACrB;IAEF,KAAK,GAAG,CAAC,WAAW,WAAW,OAAO;IAEtC,MAAM,UAAU,IAAA,6KAAY,EAAC;IAC7B,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IAEA,IAAA,gMAAc,EAAC;IACf,OAAO;AACT;AAKO,eAAe,YAAY,EAAU;IAC1C,MAAM,WAAW,IAAA,6KAAY,EAAC;IAC9B,IAAI,CAAC,UAAU;QACb,OAAO;IACT;IAEA,MAAM,SAAS,IAAA,gLAAe,EAAC;IAC/B,IAAA,gMAAc,EAAC;IACf,OAAO;AACT;AAOO,eAAe,yBAAyB,kBAA2B,KAAK;IAC7E,OAAO,IAAA,qLAAkB,EAAC;AAC5B;AAKO,eAAe,wBAAwB,IAAY,EAAE,WAAoB;IAC9E,IAAI,CAAC,QAAQ,KAAK,IAAI,OAAO,IAAI;QAC/B,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,OAAO,IAAA,oLAAiB,EAAC,KAAK,IAAI,IAAI,aAAa;IACzD,IAAA,gMAAc,EAAC;IACf,OAAO;AACT;AAKO,eAAe,wBACpB,EAAU,EACV,IAAY,EACZ,WAAoB;IAEpB,IAAI,CAAC,QAAQ,KAAK,IAAI,OAAO,IAAI;QAC/B,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,OAAO,IAAA,oLAAiB,EAAC,IAAI,KAAK,IAAI,IAAI,aAAa;IAC7D,IAAA,gMAAc,EAAC;IACf,OAAO;AACT;AAKO,eAAe,4BAA4B,EAAU;IAC1D,MAAM,SAAS,IAAA,wLAAqB,EAAC;IACrC,IAAA,gMAAc,EAAC;IACf,OAAO;AACT;AAKO,eAAe,0BAA0B,EAAU;IACxD,MAAM,SAAS,IAAA,sLAAmB,EAAC;IACnC,IAAA,gMAAc,EAAC;IACf,OAAO;AACT;AAKO,eAAe,wBAAwB,QAAgB,EAAE,QAAgB;IAC9E,MAAM,SAAS,IAAA,oLAAiB,EAAC,UAAU;IAC3C,IAAA,gMAAc,EAAC;IACf,OAAO;AACT;;;IA5KsB;IAgBA;IAOA;IAOA;IAaA;IAsDA;IAgBA;IAOA;IAaA;IAiBA;IASA;IASA;;AAxKA,gSAAA;AAgBA,gSAAA;AAOA,gSAAA;AAOA,gSAAA;AAaA,gSAAA;AAsDA,gSAAA;AAgBA,gSAAA;AAOA,gSAAA;AAaA,gSAAA;AAiBA,gSAAA;AASA,gSAAA;AASA,gSAAA","debugId":null}},
    {"offset": {"line": 789, "column": 0}, "map": {"version":3,"sources":["file:///Users/burman/repos/candy-counter/candy-counter/.next-internal/server/app/catalog/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {getAllCatalogItemsAction as '4089442ab9ca30809a71e839ff8ba121c4d9e76934'} from 'ACTIONS_MODULE0'\nexport {createCatalogItemAction as '603b773387d958e80d02013679d84da904053d58d1'} from 'ACTIONS_MODULE0'\nexport {updateCatalogItemAction as '70bf5b2b226cab423a74985f4fb03729a7d5e74b3d'} from 'ACTIONS_MODULE0'\nexport {deactivateCatalogItemAction as '40cc73549640befa7f25c4d2d6e1f025e75a359b00'} from 'ACTIONS_MODULE0'\nexport {activateCatalogItemAction as '401fb996a3d259d978963ea9fbbdd2aee17009d593'} from 'ACTIONS_MODULE0'\nexport {mergeCatalogItemsAction as '6012bac9a2901dc4d1616baeacb273d60c444e8603'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}}]
}