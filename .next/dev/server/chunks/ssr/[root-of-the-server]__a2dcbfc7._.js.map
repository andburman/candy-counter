{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///Users/burman/repos/candy-counter/candy-counter/lib/db.ts"],"sourcesContent":["import Database from \"better-sqlite3\";\nimport { join } from \"path\";\n\nlet db: Database.Database | null = null;\n\n/**\n * Get or create the database connection\n * Singleton pattern to ensure only one connection\n */\nexport function getDb(): Database.Database {\n  if (db) {\n    return db;\n  }\n\n  // Create database in the project root\n  const dbPath = join(process.cwd(), \"candy-counter.db\");\n  db = new Database(dbPath);\n  \n  // Enable foreign keys\n  db.pragma(\"foreign_keys = ON\");\n  \n  // Initialize schema\n  initializeSchema(db);\n  \n  return db;\n}\n\n/**\n * Initialize the database schema\n */\nfunction initializeSchema(database: Database.Database) {\n  const currentYear = new Date().getFullYear();\n\n  // Create candy counts table\n  database.exec(`\n    CREATE TABLE IF NOT EXISTS candy_counts (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      candy_name TEXT NOT NULL,\n      count INTEGER NOT NULL DEFAULT 0,\n      year INTEGER NOT NULL,\n      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n      UNIQUE(candy_name, year)\n    );\n  `);\n\n  // Migration: Add year column if it doesn't exist\n  try {\n    const tableInfo = database.prepare(\"PRAGMA table_info(candy_counts)\").all() as Array<{ name: string; type: string }>;\n    const hasYearColumn = tableInfo.some((col) => col.name === \"year\");\n\n    if (!hasYearColumn) {\n      // Add year column\n      database.exec(`\n        ALTER TABLE candy_counts ADD COLUMN year INTEGER;\n      `);\n\n      // Migrate existing records to current year\n      database.exec(`\n        UPDATE candy_counts SET year = ${currentYear} WHERE year IS NULL;\n      `);\n\n      // Make year NOT NULL after populating\n      database.exec(`\n        CREATE TABLE candy_counts_new (\n          id INTEGER PRIMARY KEY AUTOINCREMENT,\n          candy_name TEXT NOT NULL,\n          count INTEGER NOT NULL DEFAULT 0,\n          year INTEGER NOT NULL,\n          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n          updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n          UNIQUE(candy_name, year)\n        );\n      `);\n\n      database.exec(`\n        INSERT INTO candy_counts_new (id, candy_name, count, year, created_at, updated_at)\n        SELECT id, candy_name, count, year, created_at, updated_at FROM candy_counts;\n      `);\n\n      database.exec(`\n        DROP TABLE candy_counts;\n      `);\n\n      database.exec(`\n        ALTER TABLE candy_counts_new RENAME TO candy_counts;\n      `);\n\n      // Drop old index if it exists\n      try {\n        database.exec(`DROP INDEX IF EXISTS idx_candy_name;`);\n      } catch (e) {\n        // Index might not exist, ignore\n      }\n    }\n\n    // Drop old unique constraint on candy_name if it exists\n    // SQLite doesn't support dropping constraints directly, handled via table recreation above\n  } catch (e) {\n    // If migration fails, continue (might already be migrated)\n    console.error(\"Migration error (may be expected):\", e);\n  }\n\n  // Create index on candy_name and year for faster lookups\n  database.exec(`\n    CREATE INDEX IF NOT EXISTS idx_candy_name_year ON candy_counts(candy_name, year);\n  `);\n\n  // Create trigger to update updated_at timestamp\n  database.exec(`\n    CREATE TRIGGER IF NOT EXISTS update_candy_counts_timestamp \n    AFTER UPDATE ON candy_counts\n    BEGIN\n      UPDATE candy_counts \n      SET updated_at = CURRENT_TIMESTAMP \n      WHERE id = NEW.id;\n    END;\n  `);\n\n  // ===== CANDY CATALOG MIGRATION =====\n  \n  // Create candy_catalog table\n  database.exec(`\n    CREATE TABLE IF NOT EXISTS candy_catalog (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      name TEXT NOT NULL UNIQUE,\n      description TEXT,\n      is_active INTEGER NOT NULL DEFAULT 1,\n      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n    );\n  `);\n\n  // Create trigger to update updated_at timestamp for catalog\n  database.exec(`\n    CREATE TRIGGER IF NOT EXISTS update_candy_catalog_timestamp \n    AFTER UPDATE ON candy_catalog\n    BEGIN\n      UPDATE candy_catalog \n      SET updated_at = CURRENT_TIMESTAMP \n      WHERE id = NEW.id;\n    END;\n  `);\n\n  // Migration: Add catalog_id column if it doesn't exist\n  try {\n    const candyTableInfo = database.prepare(\"PRAGMA table_info(candy_counts)\").all() as Array<{ name: string; type: string }>;\n    const hasCatalogIdColumn = candyTableInfo.some((col) => col.name === \"catalog_id\");\n\n    if (!hasCatalogIdColumn) {\n      // Add catalog_id column (nullable initially)\n      database.exec(`\n        ALTER TABLE candy_counts ADD COLUMN catalog_id INTEGER;\n      `);\n\n      // Create index on catalog_id for performance\n      database.exec(`\n        CREATE INDEX IF NOT EXISTS idx_candy_catalog_id ON candy_counts(catalog_id);\n      `);\n    }\n  } catch (e) {\n    console.error(\"Catalog migration error (may be expected):\", e);\n  }\n\n  // Run migration to populate catalog and link existing records\n  migrateCatalogData(database);\n}\n\n/**\n * Migrate existing candy_name data to catalog system\n */\nfunction migrateCatalogData(database: Database.Database) {\n  try {\n    // Check if catalog is already populated by checking if any candy_counts have catalog_id set\n    const checkStmt = database.prepare(`\n      SELECT COUNT(*) as count \n      FROM candy_counts \n      WHERE catalog_id IS NOT NULL\n    `);\n    const result = checkStmt.get() as { count: number };\n    \n    // If catalog_id is already set, migration has been run\n    if (result.count > 0) {\n      return;\n    }\n\n    // Get all distinct candy names from candy_counts\n    const distinctNames = database.prepare(`\n      SELECT DISTINCT candy_name \n      FROM candy_counts \n      WHERE candy_name IS NOT NULL AND candy_name != ''\n    `).all() as Array<{ candy_name: string }>;\n\n    if (distinctNames.length === 0) {\n      return; // No data to migrate\n    }\n\n    // Populate catalog from existing candy names\n    const insertStmt = database.prepare(`\n      INSERT OR IGNORE INTO candy_catalog (name) \n      VALUES (?)\n    `);\n\n    for (const row of distinctNames) {\n      insertStmt.run(row.candy_name);\n    }\n\n    // Link existing candy_counts records to catalog\n    const linkStmt = database.prepare(`\n      UPDATE candy_counts \n      SET catalog_id = (\n        SELECT id \n        FROM candy_catalog \n        WHERE name = candy_counts.candy_name \n        LIMIT 1\n      )\n      WHERE catalog_id IS NULL\n    `);\n    linkStmt.run();\n\n  } catch (e) {\n    console.error(\"Catalog data migration error:\", e);\n  }\n}\n\n/**\n * Close the database connection (useful for cleanup)\n */\nexport function closeDb() {\n  if (db) {\n    db.close();\n    db = null;\n  }\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 212, "column": 0}, "map": {"version":3,"sources":["file:///Users/burman/repos/candy-counter/candy-counter/lib/candy.ts"],"sourcesContent":["import { getDb } from \"./db\";\n\nexport interface Candy {\n  id: number;\n  catalog_id: number;\n  candy_name: string; // Denormalized or from JOIN for display\n  count: number;\n  year: number;\n  created_at: string;\n  updated_at: string;\n}\n\n/**\n * Get the current year\n */\nexport function getCurrentYear(): number {\n  return new Date().getFullYear();\n}\n\n/**\n * Get all candy counts, optionally filtered by year\n */\nexport function getAllCandies(year?: number): Candy[] {\n  const db = getDb();\n  if (year !== undefined) {\n    const stmt = db.prepare(`\n      SELECT \n        cc.id,\n        cc.catalog_id,\n        COALESCE(cat.name, cc.candy_name) as candy_name,\n        cc.count,\n        cc.year,\n        cc.created_at,\n        cc.updated_at\n      FROM candy_counts cc\n      LEFT JOIN candy_catalog cat ON cc.catalog_id = cat.id\n      WHERE cc.year = ?\n      ORDER BY candy_name\n    `);\n    return stmt.all(year) as Candy[];\n  }\n  const stmt = db.prepare(`\n    SELECT \n      cc.id,\n      cc.catalog_id,\n      COALESCE(cat.name, cc.candy_name) as candy_name,\n      cc.count,\n      cc.year,\n      cc.created_at,\n      cc.updated_at\n    FROM candy_counts cc\n    LEFT JOIN candy_catalog cat ON cc.catalog_id = cat.id\n    ORDER BY cc.year DESC, candy_name\n  `);\n  return stmt.all() as Candy[];\n}\n\n/**\n * Get all candies for a specific year\n */\nexport function getCandiesByYear(year: number): Candy[] {\n  const db = getDb();\n  const stmt = db.prepare(`\n    SELECT \n      cc.id,\n      cc.catalog_id,\n      COALESCE(cat.name, cc.candy_name) as candy_name,\n      cc.count,\n      cc.year,\n      cc.created_at,\n      cc.updated_at\n    FROM candy_counts cc\n    LEFT JOIN candy_catalog cat ON cc.catalog_id = cat.id\n    WHERE cc.year = ?\n    ORDER BY candy_name\n  `);\n  return stmt.all(year) as Candy[];\n}\n\n/**\n * Get all available years that have candy data\n */\nexport function getAvailableYears(): number[] {\n  const db = getDb();\n  const stmt = db.prepare(\"SELECT DISTINCT year FROM candy_counts ORDER BY year DESC\");\n  const results = stmt.all() as Array<{ year: number }>;\n  return results.map((r) => r.year);\n}\n\n/**\n * Get a specific candy by name and year (deprecated - kept for backwards compatibility)\n * @deprecated Use getCandyByCatalogId or getCandyById instead\n */\nexport function getCandyByName(candyName: string, year?: number): Candy | null {\n  const db = getDb();\n  const targetYear = year ?? getCurrentYear();\n  const stmt = db.prepare(`\n    SELECT \n      cc.id,\n      cc.catalog_id,\n      COALESCE(cat.name, cc.candy_name) as candy_name,\n      cc.count,\n      cc.year,\n      cc.created_at,\n      cc.updated_at\n    FROM candy_counts cc\n    LEFT JOIN candy_catalog cat ON cc.catalog_id = cat.id\n    WHERE (cat.name = ? OR cc.candy_name = ?) AND cc.year = ?\n  `);\n  const candy = stmt.get(candyName, candyName, targetYear) as Candy | undefined;\n  return candy || null;\n}\n\n/**\n * Get a specific candy by catalog_id and year\n */\nexport function getCandyByCatalogId(catalogId: number, year?: number): Candy | null {\n  const db = getDb();\n  const targetYear = year ?? getCurrentYear();\n  const stmt = db.prepare(`\n    SELECT \n      cc.id,\n      cc.catalog_id,\n      COALESCE(cat.name, cc.candy_name) as candy_name,\n      cc.count,\n      cc.year,\n      cc.created_at,\n      cc.updated_at\n    FROM candy_counts cc\n    LEFT JOIN candy_catalog cat ON cc.catalog_id = cat.id\n    WHERE cc.catalog_id = ? AND cc.year = ?\n  `);\n  const candy = stmt.get(catalogId, targetYear) as Candy | undefined;\n  return candy || null;\n}\n\n/**\n * Get a specific candy by ID\n */\nexport function getCandyById(id: number): Candy | null {\n  const db = getDb();\n  const stmt = db.prepare(`\n    SELECT \n      cc.id,\n      cc.catalog_id,\n      COALESCE(cat.name, cc.candy_name) as candy_name,\n      cc.count,\n      cc.year,\n      cc.created_at,\n      cc.updated_at\n    FROM candy_counts cc\n    LEFT JOIN candy_catalog cat ON cc.catalog_id = cat.id\n    WHERE cc.id = ?\n  `);\n  const candy = stmt.get(id) as Candy | undefined;\n  return candy || null;\n}\n\n/**\n * Increment candy count (creates if doesn't exist) - uses catalog_id\n */\nexport function incrementCandy(catalogId: number, amount: number = 1, year?: number): Candy {\n  const db = getDb();\n  const targetYear = year ?? getCurrentYear();\n  \n  // Try to get existing candy\n  const existing = db.prepare(`\n    SELECT * FROM candy_counts \n    WHERE catalog_id = ? AND year = ?\n  `).get(catalogId, targetYear) as Candy | undefined;\n  \n  if (existing) {\n    // Update existing\n    const stmt = db.prepare(\n      \"UPDATE candy_counts SET count = count + ? WHERE catalog_id = ? AND year = ?\"\n    );\n    stmt.run(amount, catalogId, targetYear);\n    // Fetch the updated record\n    return getCandyById(existing.id)!;\n  } else {\n    // Get catalog name for denormalization\n    const catalogItem = db.prepare(\"SELECT name FROM candy_catalog WHERE id = ?\").get(catalogId) as { name: string } | undefined;\n    const candyName = catalogItem?.name || \"\";\n    \n    // Create new\n    const stmt = db.prepare(\n      \"INSERT INTO candy_counts (catalog_id, candy_name, count, year) VALUES (?, ?, ?, ?)\"\n    );\n    stmt.run(catalogId, candyName, amount, targetYear);\n    // Fetch the newly created record\n    const newId = db.prepare(\"SELECT last_insert_rowid()\").get() as { \"last_insert_rowid()\": number };\n    return getCandyById(newId[\"last_insert_rowid()\"])!;\n  }\n}\n\n/**\n * Decrement candy count (uses catalog_id)\n */\nexport function decrementCandy(catalogId: number, amount: number = 1, year?: number): Candy | null {\n  const db = getDb();\n  const targetYear = year ?? getCurrentYear();\n  const existing = getCandyByCatalogId(catalogId, targetYear);\n  \n  if (!existing) {\n    return null;\n  }\n  \n  const newCount = Math.max(0, existing.count - amount);\n  const stmt = db.prepare(\n    \"UPDATE candy_counts SET count = ? WHERE catalog_id = ? AND year = ?\"\n  );\n  stmt.run(newCount, catalogId, targetYear);\n  // Fetch the updated record\n  return getCandyByCatalogId(catalogId, targetYear)!;\n}\n\n/**\n * Set candy count to a specific value (uses catalog_id)\n */\nexport function setCandyCount(catalogId: number, count: number, year?: number): Candy {\n  const db = getDb();\n  const targetYear = year ?? getCurrentYear();\n  const existing = getCandyByCatalogId(catalogId, targetYear);\n  \n  if (existing) {\n    const stmt = db.prepare(\n      \"UPDATE candy_counts SET count = ? WHERE catalog_id = ? AND year = ?\"\n    );\n    stmt.run(count, catalogId, targetYear);\n    // Fetch the updated record\n    return getCandyByCatalogId(catalogId, targetYear)!;\n  } else {\n    // Get catalog name for denormalization\n    const catalogItem = db.prepare(\"SELECT name FROM candy_catalog WHERE id = ?\").get(catalogId) as { name: string } | undefined;\n    const candyName = catalogItem?.name || \"\";\n    \n    const stmt = db.prepare(\n      \"INSERT INTO candy_counts (catalog_id, candy_name, count, year) VALUES (?, ?, ?, ?)\"\n    );\n    stmt.run(catalogId, candyName, count, targetYear);\n    // Fetch the newly created record\n    const newId = db.prepare(\"SELECT last_insert_rowid()\").get() as { \"last_insert_rowid()\": number };\n    return getCandyById(newId[\"last_insert_rowid()\"])!;\n  }\n}\n\n/**\n * Delete a candy by ID\n */\nexport function deleteCandyById(id: number): boolean {\n  const db = getDb();\n  const stmt = db.prepare(\"DELETE FROM candy_counts WHERE id = ?\");\n  const result = stmt.run(id);\n  return result.changes > 0;\n}\n\n/**\n * Delete a candy by name and year (deprecated - kept for backwards compatibility)\n * @deprecated Use deleteCandyById instead\n */\nexport function deleteCandy(candyName: string, year?: number): boolean {\n  const db = getDb();\n  const targetYear = year ?? getCurrentYear();\n  const stmt = db.prepare(`\n    DELETE FROM candy_counts \n    WHERE id IN (\n      SELECT cc.id FROM candy_counts cc\n      LEFT JOIN candy_catalog cat ON cc.catalog_id = cat.id\n      WHERE (cat.name = ? OR cc.candy_name = ?) AND cc.year = ?\n    )\n  `);\n  const result = stmt.run(candyName, candyName, targetYear);\n  return result.changes > 0;\n}\n\n/**\n * Reset all candy counts to zero for a specific year\n */\nexport function resetAllCandies(year?: number): void {\n  const db = getDb();\n  if (year !== undefined) {\n    db.prepare(\"UPDATE candy_counts SET count = 0 WHERE year = ?\").run(year);\n  } else {\n    db.prepare(\"UPDATE candy_counts SET count = 0\").run();\n  }\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 450, "column": 0}, "map": {"version":3,"sources":["file:///Users/burman/repos/candy-counter/candy-counter/app/actions.ts"],"sourcesContent":["\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport {\n  getAllCandies,\n  getCandiesByYear,\n  getAvailableYears,\n  incrementCandy,\n  getCandyById,\n  deleteCandy as deleteCandyByName,\n  deleteCandyById,\n  setCandyCount,\n  getCandyByName,\n  getCurrentYear,\n  type Candy,\n} from \"@/lib/candy\";\nimport {\n  getAllCatalogItems,\n  getCatalogItemById,\n  createCatalogItem,\n  updateCatalogItem,\n  deactivateCatalogItem,\n  activateCatalogItem,\n  mergeCatalogItems,\n  type CandyCatalogItem,\n} from \"@/lib/catalog\";\nimport { getDb } from \"@/lib/db\";\n\n/**\n * Add candy (increments if exists, creates if new)\n */\nexport async function addCandy(name: string, quantity: number): Promise<Candy> {\n  if (!name || name.trim() === \"\") {\n    throw new Error(\"Candy name is required\");\n  }\n  if (quantity < 1) {\n    throw new Error(\"Quantity must be at least 1\");\n  }\n  \n  const candy = incrementCandy(name.trim(), quantity);\n  revalidatePath(\"/\");\n  return candy;\n}\n\n/**\n * Get all candies, optionally filtered by year\n */\nexport async function getAllCandiesAction(year?: number): Promise<Candy[]> {\n  return getAllCandies(year);\n}\n\n/**\n * Get all candies for a specific year\n */\nexport async function getCandiesByYearAction(year: number): Promise<Candy[]> {\n  return getCandiesByYear(year);\n}\n\n/**\n * Get all available years that have candy data\n */\nexport async function getAvailableYearsAction(): Promise<number[]> {\n  const years = getAvailableYears();\n  const currentYear = getCurrentYear();\n  // Ensure current year is always included even if no data exists yet\n  if (!years.includes(currentYear)) {\n    return [currentYear, ...years];\n  }\n  return years;\n}\n\n/**\n * Update candy by ID (updates name and/or count)\n */\nexport async function updateCandy(\n  id: number,\n  name: string,\n  count: number\n): Promise<Candy> {\n  if (!name || name.trim() === \"\") {\n    throw new Error(\"Candy name is required\");\n  }\n  if (count < 0) {\n    throw new Error(\"Count cannot be negative\");\n  }\n\n  const existing = getCandyById(id);\n  if (!existing) {\n    throw new Error(\"Candy not found\");\n  }\n\n  const db = getDb();\n  const trimmedName = name.trim();\n\n  // If name changed, need to check if new name already exists in the same year\n  if (trimmedName !== existing.candy_name) {\n    const nameExists = getCandyByName(trimmedName, existing.year);\n    if (nameExists && nameExists.id !== id) {\n      throw new Error(\"Candy with this name already exists for this year\");\n    }\n  }\n\n  // Update both name and count\n  const stmt = db.prepare(\n    \"UPDATE candy_counts SET candy_name = ?, count = ? WHERE id = ?\"\n  );\n  stmt.run(trimmedName, count, id);\n\n  const updated = getCandyById(id);\n  if (!updated) {\n    throw new Error(\"Failed to update candy\");\n  }\n\n  revalidatePath(\"/\");\n  return updated;\n}\n\n/**\n * Delete candy by ID\n */\nexport async function deleteCandy(id: number): Promise<boolean> {\n  const existing = getCandyById(id);\n  if (!existing) {\n    return false;\n  }\n\n  const result = deleteCandyByName(existing.candy_name, existing.year);\n  revalidatePath(\"/\");\n  return result;\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAEA;AACA;AAuBA;;;;;;AAKO,eAAe,SAAS,IAAY,EAAE,QAAgB;IAC3D,IAAI,CAAC,QAAQ,KAAK,IAAI,OAAO,IAAI;QAC/B,MAAM,IAAI,MAAM;IAClB;IACA,IAAI,WAAW,GAAG;QAChB,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,QAAQ,IAAA,+KAAc,EAAC,KAAK,IAAI,IAAI;IAC1C,IAAA,gMAAc,EAAC;IACf,OAAO;AACT;AAKO,eAAe,oBAAoB,IAAa;IACrD,OAAO,IAAA,8KAAa,EAAC;AACvB;AAKO,eAAe,uBAAuB,IAAY;IACvD,OAAO,IAAA,iLAAgB,EAAC;AAC1B;AAKO,eAAe;IACpB,MAAM,QAAQ,IAAA,kLAAiB;IAC/B,MAAM,cAAc,IAAA,+KAAc;IAClC,oEAAoE;IACpE,IAAI,CAAC,MAAM,QAAQ,CAAC,cAAc;QAChC,OAAO;YAAC;eAAgB;SAAM;IAChC;IACA,OAAO;AACT;AAKO,eAAe,YACpB,EAAU,EACV,IAAY,EACZ,KAAa;IAEb,IAAI,CAAC,QAAQ,KAAK,IAAI,OAAO,IAAI;QAC/B,MAAM,IAAI,MAAM;IAClB;IACA,IAAI,QAAQ,GAAG;QACb,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,WAAW,IAAA,6KAAY,EAAC;IAC9B,IAAI,CAAC,UAAU;QACb,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,KAAK,IAAA,mKAAK;IAChB,MAAM,cAAc,KAAK,IAAI;IAE7B,6EAA6E;IAC7E,IAAI,gBAAgB,SAAS,UAAU,EAAE;QACvC,MAAM,aAAa,IAAA,+KAAc,EAAC,aAAa,SAAS,IAAI;QAC5D,IAAI,cAAc,WAAW,EAAE,KAAK,IAAI;YACtC,MAAM,IAAI,MAAM;QAClB;IACF;IAEA,6BAA6B;IAC7B,MAAM,OAAO,GAAG,OAAO,CACrB;IAEF,KAAK,GAAG,CAAC,aAAa,OAAO;IAE7B,MAAM,UAAU,IAAA,6KAAY,EAAC;IAC7B,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IAEA,IAAA,gMAAc,EAAC;IACf,OAAO;AACT;AAKO,eAAe,YAAY,EAAU;IAC1C,MAAM,WAAW,IAAA,6KAAY,EAAC;IAC9B,IAAI,CAAC,UAAU;QACb,OAAO;IACT;IAEA,MAAM,SAAS,IAAA,4KAAiB,EAAC,SAAS,UAAU,EAAE,SAAS,IAAI;IACnE,IAAA,gMAAc,EAAC;IACf,OAAO;AACT;;;IAlGsB;IAgBA;IAOA;IAOA;IAaA;IA8CA;;AAzFA,gSAAA;AAgBA,gSAAA;AAOA,gSAAA;AAOA,gSAAA;AAaA,gSAAA;AA8CA,gSAAA","debugId":null}},
    {"offset": {"line": 560, "column": 0}, "map": {"version":3,"sources":["file:///Users/burman/repos/candy-counter/candy-counter/.next-internal/server/app/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {getAvailableYearsAction as '00b07d2af22679015b9a378c274a5d9d99b9ff8ded'} from 'ACTIONS_MODULE0'\nexport {getAllCandiesAction as '40274852bf4dc49511e372ce0071f7fe6d44aba2ae'} from 'ACTIONS_MODULE0'\nexport {getCandiesByYearAction as '40a05f9241e92e8314d32ec08673be86daf71b00ff'} from 'ACTIONS_MODULE0'\nexport {deleteCandy as '40d9f9ae5c1043c46ce5cc9ee55864022f6b9496fc'} from 'ACTIONS_MODULE0'\nexport {addCandy as '603c626a45f03fc635d3c576003b0595c25c09bdfb'} from 'ACTIONS_MODULE0'\nexport {updateCandy as '7059e609926d9857bcfd1d917e665406438267c074'} from 'ACTIONS_MODULE0'\nexport {getAllCandiesAction as '40274852bf4dc49511e372ce0071f7fe6d44aba2ae'} from 'ACTIONS_MODULE0'\nexport {addCandy as '603c626a45f03fc635d3c576003b0595c25c09bdfb'} from 'ACTIONS_MODULE0'\nexport {updateCandy as '7059e609926d9857bcfd1d917e665406438267c074'} from 'ACTIONS_MODULE0'\nexport {deleteCandy as '40d9f9ae5c1043c46ce5cc9ee55864022f6b9496fc'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}}]
}